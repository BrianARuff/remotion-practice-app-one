"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useMediaPlayback = exports.DEFAULT_ACCEPTABLE_TIMESHIFT = void 0;
const react_1 = require("react");
const use_audio_frame_js_1 = require("./audio/use-audio-frame.js");
const play_and_handle_not_allowed_error_js_1 = require("./play-and-handle-not-allowed-error.js");
const timeline_position_state_js_1 = require("./timeline-position-state.js");
const use_current_frame_js_1 = require("./use-current-frame.js");
const use_video_config_js_1 = require("./use-video-config.js");
const get_current_time_js_1 = require("./video/get-current-time.js");
const video_fragment_js_1 = require("./video/video-fragment.js");
const warn_about_non_seekable_media_js_1 = require("./warn-about-non-seekable-media.js");
exports.DEFAULT_ACCEPTABLE_TIMESHIFT = 0.45;
const seek = (mediaRef, time) => {
    if (!mediaRef.current) {
        return;
    }
    // iOS seeking does not support multiple decimals
    if ((0, video_fragment_js_1.isIosSafari)()) {
        mediaRef.current.currentTime = Number(time.toFixed(1));
        return;
    }
    mediaRef.current.currentTime = time;
};
const useMediaPlayback = ({ mediaRef, src, mediaType, playbackRate: localPlaybackRate, onlyWarnForMediaSeekingError, acceptableTimeshift, }) => {
    const { playbackRate: globalPlaybackRate } = (0, react_1.useContext)(timeline_position_state_js_1.TimelineContext);
    const frame = (0, use_current_frame_js_1.useCurrentFrame)();
    const absoluteFrame = (0, timeline_position_state_js_1.useTimelinePosition)();
    const [playing] = (0, timeline_position_state_js_1.usePlayingState)();
    const { fps } = (0, use_video_config_js_1.useVideoConfig)();
    const mediaStartsAt = (0, use_audio_frame_js_1.useMediaStartsAt)();
    const playbackRate = localPlaybackRate * globalPlaybackRate;
    (0, react_1.useEffect)(() => {
        var _a;
        if (!playing) {
            (_a = mediaRef.current) === null || _a === void 0 ? void 0 : _a.pause();
        }
    }, [mediaRef, mediaType, playing]);
    (0, react_1.useEffect)(() => {
        const tagName = mediaType === 'audio' ? '<Audio>' : '<Video>';
        if (!mediaRef.current) {
            throw new Error(`No ${mediaType} ref found`);
        }
        if (!src) {
            throw new Error(`No 'src' attribute was passed to the ${tagName} element.`);
        }
        const playbackRateToSet = Math.max(0, playbackRate);
        if (mediaRef.current.playbackRate !== playbackRateToSet) {
            mediaRef.current.playbackRate = playbackRateToSet;
        }
        const desiredUnclampedTime = (0, get_current_time_js_1.getMediaTime)({
            fps,
            frame,
            src,
            playbackRate: localPlaybackRate,
            startFrom: -mediaStartsAt,
            mediaType,
        });
        const { duration } = mediaRef.current;
        const shouldBeTime = !Number.isNaN(duration) && Number.isFinite(duration)
            ? Math.min(duration, desiredUnclampedTime)
            : desiredUnclampedTime;
        const isTime = mediaRef.current.currentTime;
        const timeShift = Math.abs(shouldBeTime - isTime);
        if (timeShift > acceptableTimeshift) {
            // If scrubbing around, adjust timing
            // or if time shift is bigger than 0.45sec
            seek(mediaRef, shouldBeTime);
            if (!onlyWarnForMediaSeekingError) {
                (0, warn_about_non_seekable_media_js_1.warnAboutNonSeekableMedia)(mediaRef.current, onlyWarnForMediaSeekingError ? 'console-warning' : 'console-error');
            }
            return;
        }
        // Only perform a seek if the time is not already the same.
        // Chrome rounds to 6 digits, so 0.033333333 -> 0.033333,
        // therefore a threshold is allowed.
        // Refer to the https://github.com/remotion-dev/video-buffering-example
        // which is fixed by only seeking conditionally.
        const makesSenseToSeek = Math.abs(mediaRef.current.currentTime - shouldBeTime) > 0.00001;
        if (!playing || absoluteFrame === 0) {
            if (makesSenseToSeek) {
                seek(mediaRef, shouldBeTime);
            }
        }
        if (mediaRef.current.paused && !mediaRef.current.ended && playing) {
            if (makesSenseToSeek) {
                seek(mediaRef, shouldBeTime);
            }
            (0, play_and_handle_not_allowed_error_js_1.playAndHandleNotAllowedError)(mediaRef, mediaType);
        }
    }, [
        absoluteFrame,
        fps,
        playbackRate,
        frame,
        mediaRef,
        mediaType,
        playing,
        src,
        mediaStartsAt,
        localPlaybackRate,
        onlyWarnForMediaSeekingError,
        acceptableTimeshift,
    ]);
};
exports.useMediaPlayback = useMediaPlayback;
