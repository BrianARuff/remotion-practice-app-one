"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.selectComposition = exports.internalSelectComposition = exports.internalSelectCompositionRaw = void 0;
const remotion_1 = require("remotion");
const TimeoutSettings_1 = require("./browser/TimeoutSettings");
const handle_javascript_exception_1 = require("./error-handling/handle-javascript-exception");
const find_closest_package_json_1 = require("./find-closest-package-json");
const get_browser_instance_1 = require("./get-browser-instance");
const logger_1 = require("./logger");
const prepare_server_1 = require("./prepare-server");
const puppeteer_evaluate_1 = require("./puppeteer-evaluate");
const seek_to_frame_1 = require("./seek-to-frame");
const set_props_and_env_1 = require("./set-props-and-env");
const validate_puppeteer_timeout_1 = require("./validate-puppeteer-timeout");
const wrap_with_error_handling_1 = require("./wrap-with-error-handling");
const innerSelectComposition = async ({ page, onBrowserLog, serializedInputPropsWithCustomSchema, envVariables, serveUrl, timeoutInMilliseconds, port, id, indent, logLevel, }) => {
    if (onBrowserLog) {
        page.on('console', (log) => {
            onBrowserLog({
                stackTrace: log.stackTrace(),
                text: log.text,
                type: log.type,
            });
        });
    }
    (0, validate_puppeteer_timeout_1.validatePuppeteerTimeout)(timeoutInMilliseconds);
    await (0, set_props_and_env_1.setPropsAndEnv)({
        serializedInputPropsWithCustomSchema,
        envVariables,
        page,
        serveUrl,
        initialFrame: 0,
        timeoutInMilliseconds,
        proxyPort: port,
        retriesRemaining: 2,
        audioEnabled: false,
        videoEnabled: false,
        indent,
        logLevel,
    });
    await (0, puppeteer_evaluate_1.puppeteerEvaluateWithCatch)({
        page,
        pageFunction: () => {
            window.remotion_setBundleMode({
                type: 'evaluation',
            });
        },
        frame: null,
        args: [],
    });
    await (0, seek_to_frame_1.waitForReady)({ page, timeoutInMilliseconds, frame: null });
    logger_1.Log.verboseAdvanced({
        indent,
        tag: 'selectComposition()',
        logLevel,
    }, 'Running calculateMetadata()...');
    const time = Date.now();
    const { value: result, size } = await (0, puppeteer_evaluate_1.puppeteerEvaluateWithCatch)({
        pageFunction: (_id) => {
            return window.remotion_calculateComposition(_id);
        },
        frame: null,
        page,
        args: [id],
    });
    logger_1.Log.verboseAdvanced({
        indent,
        tag: 'selectComposition()',
        logLevel,
    }, `calculateMetadata() took ${Date.now() - time}ms`);
    const res = result;
    const { width, durationInFrames, fps, height, defaultCodec } = res;
    return {
        metadata: {
            id,
            width,
            height,
            fps,
            durationInFrames,
            props: remotion_1.Internals.deserializeJSONWithCustomFields(res.serializedResolvedPropsWithCustomSchema),
            defaultProps: remotion_1.Internals.deserializeJSONWithCustomFields(res.serializedDefaultPropsWithCustomSchema),
            defaultCodec,
        },
        propsSize: size,
    };
};
const internalSelectCompositionRaw = async (options) => {
    const cleanup = [];
    const { puppeteerInstance, browserExecutable, chromiumOptions, serveUrl: serveUrlOrWebpackUrl, logLevel, indent, port, envVariables, id, serializedInputPropsWithCustomSchema, onBrowserLog, server, timeoutInMilliseconds, offthreadVideoCacheSizeInBytes, } = options;
    const { page, cleanup: cleanupPage } = await (0, get_browser_instance_1.getPageAndCleanupFn)({
        passedInInstance: puppeteerInstance,
        browserExecutable,
        chromiumOptions,
        context: null,
        forceDeviceScaleFactor: undefined,
        indent,
        logLevel,
    });
    cleanup.push(() => cleanupPage());
    return new Promise((resolve, reject) => {
        const onError = (err) => reject(err);
        cleanup.push((0, handle_javascript_exception_1.handleJavascriptException)({
            page,
            frame: null,
            onError,
        }));
        (0, prepare_server_1.makeOrReuseServer)(options.server, {
            webpackConfigOrServeUrl: serveUrlOrWebpackUrl,
            port,
            remotionRoot: (0, find_closest_package_json_1.findRemotionRoot)(),
            concurrency: 1,
            logLevel,
            indent,
            offthreadVideoCacheSizeInBytes,
        }, {
            onDownload: () => undefined,
            onError,
        })
            .then(({ server: { serveUrl, offthreadPort, sourceMap }, cleanupServer }) => {
            page.setBrowserSourceMapContext(sourceMap);
            cleanup.push(() => cleanupServer(true));
            return innerSelectComposition({
                serveUrl,
                page,
                port: offthreadPort,
                browserExecutable,
                chromiumOptions,
                envVariables,
                id,
                serializedInputPropsWithCustomSchema,
                onBrowserLog,
                timeoutInMilliseconds,
                logLevel,
                indent,
                puppeteerInstance,
                server,
                offthreadVideoCacheSizeInBytes,
            });
        })
            .then((data) => {
            return resolve(data);
        })
            .catch((err) => {
            reject(err);
        })
            .finally(() => {
            cleanup.forEach((c) => {
                c();
            });
        });
    });
};
exports.internalSelectCompositionRaw = internalSelectCompositionRaw;
exports.internalSelectComposition = (0, wrap_with_error_handling_1.wrapWithErrorHandling)(exports.internalSelectCompositionRaw);
/**
 * @description Gets a composition defined in a Remotion project based on a Webpack bundle.
 * @see [Documentation](https://www.remotion.dev/docs/renderer/select-composition)
 */
const selectComposition = async (options) => {
    const { id, serveUrl, browserExecutable, chromiumOptions, envVariables, inputProps, onBrowserLog, port, puppeteerInstance, timeoutInMilliseconds, verbose, logLevel, offthreadVideoCacheSizeInBytes, } = options;
    const data = await (0, exports.internalSelectComposition)({
        id,
        serveUrl,
        browserExecutable: browserExecutable !== null && browserExecutable !== void 0 ? browserExecutable : null,
        chromiumOptions: chromiumOptions !== null && chromiumOptions !== void 0 ? chromiumOptions : {},
        envVariables: envVariables !== null && envVariables !== void 0 ? envVariables : {},
        serializedInputPropsWithCustomSchema: remotion_1.Internals.serializeJSONWithDate({
            indent: undefined,
            staticBase: null,
            data: inputProps !== null && inputProps !== void 0 ? inputProps : {},
        }).serializedString,
        onBrowserLog: onBrowserLog !== null && onBrowserLog !== void 0 ? onBrowserLog : null,
        port: port !== null && port !== void 0 ? port : null,
        puppeteerInstance,
        timeoutInMilliseconds: timeoutInMilliseconds !== null && timeoutInMilliseconds !== void 0 ? timeoutInMilliseconds : TimeoutSettings_1.DEFAULT_TIMEOUT,
        logLevel: (logLevel !== null && logLevel !== void 0 ? logLevel : verbose) ? 'verbose' : 'info',
        indent: false,
        server: undefined,
        offthreadVideoCacheSizeInBytes: offthreadVideoCacheSizeInBytes !== null && offthreadVideoCacheSizeInBytes !== void 0 ? offthreadVideoCacheSizeInBytes : null,
    });
    return data.metadata;
};
exports.selectComposition = selectComposition;
