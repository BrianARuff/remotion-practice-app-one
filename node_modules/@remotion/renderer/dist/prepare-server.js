"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.makeOrReuseServer = exports.prepareServer = void 0;
const node_fs_1 = require("node:fs");
const node_path_1 = __importDefault(require("node:path"));
const remotion_1 = require("remotion");
const download_and_map_assets_to_file_1 = require("./assets/download-and-map-assets-to-file");
const download_map_1 = require("./assets/download-map");
const get_bundle_url_from_serve_url_1 = require("./get-bundle-url-from-serve-url");
const is_serve_url_1 = require("./is-serve-url");
const logger_1 = require("./logger");
const serve_static_1 = require("./serve-static");
const symbolicate_stacktrace_1 = require("./symbolicate-stacktrace");
const wait_for_symbolication_error_to_be_done_1 = require("./wait-for-symbolication-error-to-be-done");
const prepareServer = async ({ webpackConfigOrServeUrl, port, remotionRoot, concurrency, logLevel, indent, offthreadVideoCacheSizeInBytes, }) => {
    const downloadMap = (0, download_map_1.makeDownloadMap)();
    logger_1.Log.verboseAdvanced({ indent, logLevel }, 'Created directory for temporary files', downloadMap.assetDir);
    if ((0, is_serve_url_1.isServeUrl)(webpackConfigOrServeUrl)) {
        const { port: offthreadPort, close: closeProxy, compositor: comp, } = await (0, serve_static_1.serveStatic)(null, {
            port,
            downloadMap,
            remotionRoot,
            concurrency,
            logLevel,
            indent,
            offthreadVideoCacheSizeInBytes,
        });
        return Promise.resolve({
            serveUrl: webpackConfigOrServeUrl,
            closeServer: () => {
                (0, download_map_1.cleanDownloadMap)(downloadMap);
                return closeProxy();
            },
            offthreadPort,
            compositor: comp,
            sourceMap: (0, symbolicate_stacktrace_1.getSourceMapFromRemoteUrl)((0, get_bundle_url_from_serve_url_1.getBundleMapUrlFromServeUrl)(webpackConfigOrServeUrl)).catch((err) => {
                logger_1.Log.verbose('Could not fetch sourcemap for ', webpackConfigOrServeUrl, err);
                return null;
            }),
            downloadMap,
        });
    }
    // Check if the path has a `index.html` file
    const indexFile = node_path_1.default.join(webpackConfigOrServeUrl, 'index.html');
    const exists = (0, node_fs_1.existsSync)(indexFile);
    if (!exists) {
        throw new Error(`Tried to serve the Webpack bundle on a HTTP server, but the file ${indexFile} does not exist. Is this a valid path to a Webpack bundle?`);
    }
    const sourceMap = (0, symbolicate_stacktrace_1.getSourceMapFromLocalFile)(node_path_1.default.join(webpackConfigOrServeUrl, remotion_1.Internals.bundleName));
    const { port: serverPort, close, compositor, } = await (0, serve_static_1.serveStatic)(webpackConfigOrServeUrl, {
        port,
        downloadMap,
        remotionRoot,
        concurrency,
        logLevel,
        indent,
        offthreadVideoCacheSizeInBytes,
    });
    return Promise.resolve({
        closeServer: async (force) => {
            sourceMap.then((s) => s === null || s === void 0 ? void 0 : s.destroy());
            (0, download_map_1.cleanDownloadMap)(downloadMap);
            if (!force) {
                await (0, wait_for_symbolication_error_to_be_done_1.waitForSymbolicationToBeDone)();
            }
            return close();
        },
        serveUrl: `http://localhost:${serverPort}`,
        offthreadPort: serverPort,
        compositor,
        sourceMap,
        downloadMap,
    });
};
exports.prepareServer = prepareServer;
const makeOrReuseServer = async (server, config, { onDownload, onError, }) => {
    if (server) {
        const cleanupOnDownload = (0, download_and_map_assets_to_file_1.attachDownloadListenerToEmitter)(server.downloadMap, onDownload);
        const cleanupError = server.downloadMap.emitter.addEventListener('error', ({ detail: { error } }) => {
            onError(error);
        });
        return {
            server,
            cleanupServer: () => {
                cleanupOnDownload();
                cleanupError();
                return Promise.resolve();
            },
        };
    }
    const newServer = await (0, exports.prepareServer)(config);
    const cleanupOnDownloadNew = (0, download_and_map_assets_to_file_1.attachDownloadListenerToEmitter)(newServer.downloadMap, onDownload);
    const cleanupErrorNew = newServer.downloadMap.emitter.addEventListener('error', ({ detail: { error } }) => {
        onError(error);
    });
    return {
        server: newServer,
        cleanupServer: (force) => {
            newServer.closeServer(force);
            cleanupOnDownloadNew();
            cleanupErrorNew();
            return Promise.resolve();
        },
    };
};
exports.makeOrReuseServer = makeOrReuseServer;
