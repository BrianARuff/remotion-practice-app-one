"use strict";
/**
 * Copyright 2017 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getRevisionInfo = exports.downloadBrowser = void 0;
const childProcess = __importStar(require("node:child_process"));
const fs = __importStar(require("node:fs"));
const os = __importStar(require("node:os"));
const path = __importStar(require("node:path"));
const extract_zip_1 = __importDefault(require("extract-zip"));
const node_util_1 = require("node:util");
const assert_1 = require("./assert");
const download_file_1 = require("../assets/download-file");
const logger_1 = require("../logger");
const get_download_destination_1 = require("./get-download-destination");
const downloadURLs = {
    linux: 'https://github.com/Alex313031/thorium/releases/download/M114.0.5735.205/thorium-browser_114.0.5735.205_amd64.zip',
    mac: 'https://github.com/Alex313031/Thorium-Special/releases/download/M114.0.5735.205-1/Thorium_MacOS_X64.dmg',
    mac_arm: 'https://github.com/Alex313031/Thorium-Special/releases/download/M114.0.5735.205-1/Thorium_MacOS_ARM.dmg',
    win64: 'https://github.com/Alex313031/Thorium-Win/releases/download/M114.0.5735.205/Thorium_114.0.5735.205.zip',
};
function getThoriumDownloadUrl(platform) {
    return downloadURLs[platform];
}
const readdirAsync = fs.promises.readdir;
const mkdirAsync = fs.promises.mkdir;
const unlinkAsync = (0, node_util_1.promisify)(fs.unlink.bind(fs));
const chmodAsync = (0, node_util_1.promisify)(fs.chmod.bind(fs));
function existsAsync(filePath) {
    return new Promise((resolve) => {
        fs.access(filePath, (err) => {
            return resolve(!err);
        });
    });
}
const getPlatform = () => {
    const platform = os.platform();
    switch (platform) {
        case 'darwin':
            return os.arch() === 'arm64' ? 'mac_arm' : 'mac';
        case 'linux':
            return 'linux';
        case 'win32':
            return 'win64';
        default:
            (0, assert_1.assert)(false, 'Unsupported platform: ' + platform);
    }
};
const destination = '.thorium';
const getDownloadsFolder = () => {
    return path.join((0, get_download_destination_1.getDownloadsCacheDir)(), destination);
};
const downloadBrowser = async (options) => {
    const platform = getPlatform();
    const downloadURL = getThoriumDownloadUrl(platform);
    const fileName = downloadURL.split('/').pop();
    (0, assert_1.assert)(fileName, `A malformed download URL was found: ${downloadURL}.`);
    const downloadsFolder = getDownloadsFolder();
    const archivePath = path.join(downloadsFolder, fileName);
    const outputPath = getFolderPath(downloadsFolder, platform);
    if (await existsAsync(outputPath)) {
        return (0, exports.getRevisionInfo)();
    }
    if (!(await existsAsync(downloadsFolder))) {
        await mkdirAsync(downloadsFolder, {
            recursive: true,
        });
    }
    // Use system Chromium builds on Linux ARM devices
    if (os.platform() !== 'darwin' && os.arch() === 'arm64') {
        throw new Error('The chromium binary is not available for arm64.' +
            '\nIf you are on Ubuntu, you can install with: ' +
            '\n\n sudo apt install chromium\n' +
            '\n\n sudo apt install chromium-browser\n');
    }
    try {
        let lastProgress = 0;
        await (0, download_file_1.downloadFile)({
            url: downloadURL,
            to: () => archivePath,
            onProgress: (progress) => {
                if (progress.downloaded > lastProgress + 10000000) {
                    lastProgress = progress.downloaded;
                    logger_1.Log.info(`Downloading Thorium - ${toMegabytes(progress.downloaded)}/${toMegabytes(progress.totalSize)}`);
                }
            },
            indent: options.indent,
            logLevel: options.logLevel,
        });
        await install({ archivePath, folderPath: outputPath });
    }
    finally {
        if (await existsAsync(archivePath)) {
            await unlinkAsync(archivePath);
        }
    }
    const revisionInfo = (0, exports.getRevisionInfo)();
    await chmodAsync(revisionInfo.executablePath, 0o755);
    return revisionInfo;
};
exports.downloadBrowser = downloadBrowser;
const getFolderPath = (downloadsFolder, platform) => {
    return path.resolve(downloadsFolder, platform);
};
const getExecutablePath = () => {
    const downloadsFolder = getDownloadsFolder();
    const platform = getPlatform();
    const folderPath = getFolderPath(downloadsFolder, platform);
    if (platform === 'mac' || platform === 'mac_arm') {
        return path.join(folderPath, 'Thorium.app', 'Contents', 'MacOS', 'Thorium');
    }
    if (platform === 'linux') {
        return path.join(folderPath, 'thorium');
    }
    if (platform === 'win64') {
        return path.join(folderPath, 'BIN', 'thorium.exe');
    }
    throw new Error('Can not download browser for platform: ' + platform);
};
const getRevisionInfo = () => {
    const executablePath = getExecutablePath();
    const downloadsFolder = getDownloadsFolder();
    const platform = getPlatform();
    const folderPath = getFolderPath(downloadsFolder, platform);
    const url = getThoriumDownloadUrl(platform);
    const local = fs.existsSync(folderPath);
    return {
        executablePath,
        folderPath,
        local,
        url,
    };
};
exports.getRevisionInfo = getRevisionInfo;
async function install({ archivePath, folderPath, }) {
    if (archivePath.endsWith('.zip')) {
        return (0, extract_zip_1.default)(archivePath, { dir: folderPath });
    }
    if (archivePath.endsWith('.dmg')) {
        await mkdirAsync(folderPath);
        return _installDMG(archivePath, folderPath);
    }
    throw new Error(`Unsupported archive format: ${archivePath}`);
}
function _installDMG(dmgPath, folderPath) {
    let mountPath;
    return new Promise((fulfill, reject) => {
        const mountCommand = `hdiutil attach -nobrowse -noautoopen "${dmgPath}"`;
        childProcess.exec(mountCommand, (err, stdout) => {
            if (err) {
                return reject(err);
            }
            const volumes = stdout.match(/\/Volumes\/(.*)/m);
            if (!volumes) {
                return reject(new Error(`Could not find volume path in ${stdout}`));
            }
            mountPath = volumes[0];
            readdirAsync(mountPath)
                .then((fileNames) => {
                const appName = fileNames.find((item) => {
                    return typeof item === 'string' && item.endsWith('.app');
                });
                if (!appName) {
                    return reject(new Error(`Cannot find app in ${mountPath}`));
                }
                const copyPath = path.join(mountPath, appName);
                childProcess.exec(`cp -R "${copyPath}" "${folderPath}"`, (_err) => {
                    if (_err) {
                        reject(_err);
                    }
                    else {
                        fulfill();
                    }
                });
            })
                .catch(reject);
        });
    })
        .catch((error) => {
        console.error(error);
    })
        .finally(() => {
        if (!mountPath) {
            return;
        }
        const unmountCommand = `hdiutil detach "${mountPath}" -quiet`;
        childProcess.exec(unmountCommand, (err) => {
            if (err) {
                console.error(`Error unmounting dmg: ${err}`);
            }
        });
    });
}
function toMegabytes(bytes) {
    const mb = bytes / 1024 / 1024;
    return `${Math.round(mb * 10) / 10} Mb`;
}
