"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.seekToFrame = exports.waitForReady = void 0;
const _1 = require(".");
const symbolicateable_error_1 = require("./error-handling/symbolicateable-error");
const parse_browser_error_stack_1 = require("./parse-browser-error-stack");
const puppeteer_evaluate_1 = require("./puppeteer-evaluate");
const waitForReady = ({ page, timeoutInMilliseconds, frame, }) => {
    const waitForReadyProm = new Promise((resolve, reject) => {
        page
            .mainFrame()
            ._mainWorld.waitForFunction({
            browser: page.browser,
            // Increase timeout so the delayRender() timeout fires earlier
            timeout: timeoutInMilliseconds + 3000,
            pageFunction: 'window.remotion_renderReady === true',
            title: frame === null
                ? 'the page to render the React component'
                : `the page to render the React component at frame ${frame}`,
        })
            .then((a) => {
            return resolve(a);
        })
            .catch((err) => {
            if (err.message.includes('timeout') &&
                err.message.includes('exceeded')) {
                (0, puppeteer_evaluate_1.puppeteerEvaluateWithCatchAndTimeout)({
                    pageFunction: () => {
                        return Object.keys(window.remotion_delayRenderTimeouts)
                            .map((id, i) => {
                            const { label } = window.remotion_delayRenderTimeouts[id];
                            if (label === null) {
                                return `${i + 1}. (no label)`;
                            }
                            return `"${i + 1}. ${label}"`;
                        })
                            .join(', ');
                    },
                    args: [],
                    frame,
                    page,
                })
                    .then((res) => {
                    reject(new Error(`Timeout exceeded rendering the component${frame ? ' at frame ' + frame : ''}. ${res.value ? `Open delayRender() handles: ${res.value}` : ''}`));
                })
                    .catch((newErr) => {
                    _1.RenderInternals.Log.warn('Tried to get delayRender() handles for timeout, but could not do so because of', newErr);
                    // Ignore, use prev error
                    reject(err);
                });
            }
            else {
                reject(err);
            }
        });
    });
    const waitForErrorProm = new Promise((_shouldNeverResolve, reject) => {
        page
            .mainFrame()
            ._mainWorld.waitForFunction({
            browser: page.browser,
            timeout: null,
            pageFunction: 'window.remotion_cancelledError !== undefined',
            title: 'remotion_cancelledError variable to appear on the page',
        })
            .then(() => {
            return (0, puppeteer_evaluate_1.puppeteerEvaluateWithCatch)({
                pageFunction: () => window.remotion_cancelledError,
                args: [],
                frame: null,
                page,
            });
        })
            .then(({ value: val }) => {
            if (typeof val !== 'string') {
                reject(val);
                return;
            }
            reject(new symbolicateable_error_1.SymbolicateableError({
                frame: null,
                stack: val,
                name: 'CancelledError',
                message: val.split('\n')[0],
                stackFrame: (0, parse_browser_error_stack_1.parseStack)(val.split('\n')),
            }));
        })
            .catch((err) => {
            if (err.message.includes('timeout') &&
                err.message.includes('exceeded')) {
                // Don't care if a error never appeared
            }
            else {
                reject(err);
            }
        });
    });
    return Promise.race([
        new Promise((_, reject) => {
            page.on("disposed" /* PageEmittedEvents.Disposed */, () => {
                reject(new Error('Target closed (page disposed)'));
            });
        }),
        new Promise((_, reject) => {
            page.browser.on("closed-silent" /* BrowserEmittedEvents.ClosedSilent */, () => {
                reject(new Error('Target closed'));
            });
        }),
        waitForReadyProm,
        waitForErrorProm,
    ]);
};
exports.waitForReady = waitForReady;
const seekToFrame = async ({ frame, page, composition, timeoutInMilliseconds, }) => {
    await (0, exports.waitForReady)({ page, timeoutInMilliseconds, frame: null });
    await (0, puppeteer_evaluate_1.puppeteerEvaluateWithCatchAndTimeout)({
        pageFunction: (f, c) => {
            window.remotion_setFrame(f, c);
        },
        args: [frame, composition],
        frame,
        page,
    });
    await (0, exports.waitForReady)({ page, timeoutInMilliseconds, frame });
    await page.evaluateHandle('document.fonts.ready');
};
exports.seekToFrame = seekToFrame;
