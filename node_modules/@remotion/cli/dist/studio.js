"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.studioCommand = void 0;
const node_crypto_1 = __importDefault(require("node:crypto"));
const node_fs_1 = require("node:fs");
const node_path_1 = __importDefault(require("node:path"));
const better_opn_1 = require("./better-opn");
const chalk_1 = require("./chalk");
const config_1 = require("./config");
const convert_entry_point_to_serve_url_1 = require("./convert-entry-point-to-serve-url");
const entry_point_1 = require("./entry-point");
const get_env_1 = require("./get-env");
const get_input_props_1 = require("./get-input-props");
const get_network_address_1 = require("./get-network-address");
const log_1 = require("./log");
const parse_command_line_1 = require("./parse-command-line");
const get_absolute_public_dir_1 = require("./preview-server/get-absolute-public-dir");
const live_events_1 = require("./preview-server/live-events");
const public_folder_1 = require("./preview-server/public-folder");
const start_server_1 = require("./preview-server/start-server");
const server_ready_comment_1 = require("./server-ready-comment");
const watch_root_file_1 = require("./watch-root-file");
const noop = () => undefined;
const getShouldOpenBrowser = () => {
    var _a;
    // Minimist quirk: Adding `--no-open` flag will result in {['no-open']: false, open: true}
    // @ts-expect-error
    if (parse_command_line_1.parsedCli.open === false) {
        return {
            shouldOpenBrowser: false,
            reasonForBrowserDecision: '--no-open specified',
        };
    }
    if (((_a = process.env.BROWSER) !== null && _a !== void 0 ? _a : '').toLowerCase() === 'none') {
        return {
            shouldOpenBrowser: false,
            reasonForBrowserDecision: 'env BROWSER=none was set',
        };
    }
    if (config_1.ConfigInternals.getShouldOpenBrowser() === false) {
        return { shouldOpenBrowser: false, reasonForBrowserDecision: 'Config file' };
    }
    return { shouldOpenBrowser: true, reasonForBrowserDecision: 'default' };
};
const getPort = () => {
    if (parse_command_line_1.parsedCli.port) {
        return parse_command_line_1.parsedCli.port;
    }
    const serverPort = config_1.ConfigInternals.getServerPort();
    if (serverPort) {
        return serverPort;
    }
    return null;
};
const studioCommand = async (remotionRoot, args) => {
    const { file, reason } = (0, entry_point_1.findEntryPoint)(args, remotionRoot);
    log_1.Log.verbose('Entry point:', file, 'reason:', reason);
    if (!file) {
        log_1.Log.error('No Remotion entrypoint was found. Specify an additional argument manually:');
        log_1.Log.error('  npx remotion studio src/index.ts');
        log_1.Log.error('See https://www.remotion.dev/docs/register-root for more information.');
        process.exit(1);
    }
    const desiredPort = getPort();
    const fullEntryPath = (0, convert_entry_point_to_serve_url_1.convertEntryPointToServeUrl)(file);
    let inputProps = (0, get_input_props_1.getInputProps)((newProps) => {
        (0, live_events_1.waitForLiveEventsListener)().then((listener) => {
            inputProps = newProps;
            listener.sendEventToClient({
                type: 'new-input-props',
                newProps,
            });
        });
    });
    let envVariables = await (0, get_env_1.getEnvironmentVariables)((newEnvVariables) => {
        (0, live_events_1.waitForLiveEventsListener)().then((listener) => {
            envVariables = newEnvVariables;
            listener.sendEventToClient({
                type: 'new-env-variables',
                newEnvVariables,
            });
        });
    });
    const publicDir = (0, get_absolute_public_dir_1.getAbsolutePublicDir)({
        userPassedPublicDir: config_1.ConfigInternals.getPublicDir(),
        remotionRoot,
    });
    const hash = node_crypto_1.default.randomBytes(6).toString('hex');
    const outputHashPrefix = '/outputs-';
    const outputHash = `${outputHashPrefix}${hash}`;
    const staticHashPrefix = '/static-';
    const staticHash = `${staticHashPrefix}${hash}`;
    (0, public_folder_1.initPublicFolderWatch)({
        publicDir,
        remotionRoot,
        onUpdate: () => {
            (0, live_events_1.waitForLiveEventsListener)().then((listener) => {
                const files = (0, public_folder_1.getFiles)();
                listener.sendEventToClient({
                    type: 'new-public-folder',
                    files,
                    folderExists: files.length > 0
                        ? publicDir
                        : (0, node_fs_1.existsSync)(publicDir)
                            ? publicDir
                            : null,
                });
            });
        },
        staticHash,
    });
    (0, watch_root_file_1.watchRootFile)(remotionRoot);
    const { port, liveEventsServer } = await (0, start_server_1.startServer)({
        entry: node_path_1.default.resolve(__dirname, 'previewEntry.js'),
        userDefinedComponent: fullEntryPath,
        getCurrentInputProps: () => inputProps,
        getEnvVariables: () => envVariables,
        port: desiredPort,
        maxTimelineTracks: config_1.ConfigInternals.getMaxTimelineTracks(),
        remotionRoot,
        keyboardShortcutsEnabled: config_1.ConfigInternals.getKeyboardShortcutsEnabled(),
        publicDir,
        webpackOverride: config_1.ConfigInternals.getWebpackOverrideFn(),
        poll: config_1.ConfigInternals.getWebpackPolling(),
        userPassedPublicDir: config_1.ConfigInternals.getPublicDir(),
        staticHash,
        staticHashPrefix,
        outputHash,
        outputHashPrefix,
    });
    (0, live_events_1.setLiveEventsListener)(liveEventsServer);
    const networkAddress = (0, get_network_address_1.getNetworkAddress)();
    if (networkAddress) {
        (0, server_ready_comment_1.setServerReadyComment)(`Local: ${chalk_1.chalk.underline(`http://localhost:${port}`)}, Network: ${chalk_1.chalk.underline(`http://${networkAddress}:${port}`)}`);
    }
    else {
        (0, server_ready_comment_1.setServerReadyComment)(`http://localhost:${port}`);
    }
    (0, server_ready_comment_1.printServerReadyComment)('Server ready');
    const { reasonForBrowserDecision, shouldOpenBrowser } = getShouldOpenBrowser();
    if (shouldOpenBrowser) {
        await (0, better_opn_1.openBrowser)({
            url: `http://localhost:${port}`,
            browserArgs: parse_command_line_1.parsedCli['browser-args'],
            browserFlag: parse_command_line_1.parsedCli.browser,
        });
    }
    else {
        log_1.Log.verbose(`Not opening browser, reason: ${reasonForBrowserDecision}`);
    }
    await new Promise(noop);
};
exports.studioCommand = studioCommand;
