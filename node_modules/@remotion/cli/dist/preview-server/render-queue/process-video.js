"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.processVideoJob = void 0;
const convert_entry_point_to_serve_url_1 = require("../../convert-entry-point-to-serve-url");
const get_cli_options_1 = require("../../get-cli-options");
const render_1 = require("../../render-flows/render");
const processVideoJob = async ({ job, remotionRoot, entryPoint, onProgress, addCleanupCallback, }) => {
    var _a, _b, _c;
    if (job.type !== 'video' && job.type !== 'sequence') {
        throw new Error('Expected video job');
    }
    const { publicDir, browserExecutable, port, browser, ffmpegOverride } = await (0, get_cli_options_1.getCliOptions)({
        isLambda: false,
        type: 'still',
        remotionRoot,
    });
    const fullEntryPoint = (0, convert_entry_point_to_serve_url_1.convertEntryPointToServeUrl)(entryPoint);
    await (0, render_1.renderVideoFlow)({
        remotionRoot,
        browser,
        browserExecutable,
        chromiumOptions: job.chromiumOptions,
        entryPointReason: 'same as Studio',
        envVariables: job.envVariables,
        height: null,
        fullEntryPoint,
        serializedInputPropsWithCustomSchema: job.serializedInputPropsWithCustomSchema,
        overwrite: true,
        port,
        publicDir,
        puppeteerTimeout: job.delayRenderTimeout,
        jpegQuality: (_a = job.jpegQuality) !== null && _a !== void 0 ? _a : undefined,
        remainingArgs: [],
        scale: job.scale,
        width: null,
        compositionIdFromUi: job.compositionId,
        logLevel: job.verbose ? 'verbose' : 'info',
        onProgress,
        indent: true,
        concurrency: job.concurrency,
        everyNthFrame: job.type === 'video' ? job.everyNthFrame : 1,
        frameRange: [job.startFrame, job.endFrame],
        quiet: false,
        shouldOutputImageSequence: job.type === 'sequence',
        addCleanupCallback,
        outputLocationFromUI: job.outName,
        uiCodec: job.type === 'video' ? job.codec : null,
        uiImageFormat: job.imageFormat,
        cancelSignal: job.cancelToken.cancelSignal,
        crf: job.type === 'video' ? job.crf : null,
        ffmpegOverride,
        audioBitrate: job.type === 'video' ? job.audioBitrate : null,
        muted: job.type === 'video' ? job.muted : true,
        enforceAudioTrack: job.type === 'video' ? job.enforceAudioTrack : false,
        proResProfile: job.type === 'video' ? (_b = job.proResProfile) !== null && _b !== void 0 ? _b : undefined : undefined,
        x264Preset: job.type === 'video' ? (_c = job.x264Preset) !== null && _c !== void 0 ? _c : undefined : undefined,
        pixelFormat: job.type === 'video' ? job.pixelFormat : 'yuv420p',
        videoBitrate: job.type === 'video' ? job.videoBitrate : null,
        numberOfGifLoops: job.type === 'video' ? job.numberOfGifLoops : null,
        audioCodec: job.type === 'video' ? job.audioCodec : null,
        disallowParallelEncoding: job.type === 'video' ? job.disallowParallelEncoding : false,
        offthreadVideoCacheSizeInBytes: job.offthreadVideoCacheSizeInBytes,
        colorSpace: job.type === 'video' ? job.colorSpace : 'default',
    });
};
exports.processVideoJob = processVideoJob;
