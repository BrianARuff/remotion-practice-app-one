"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.extractEnumJsonPaths = void 0;
const extractEnumJsonPaths = (schema, zodRuntime, currentPath) => {
    const def = schema._def;
    const typeName = def.typeName;
    switch (typeName) {
        case zodRuntime.ZodFirstPartyTypeKind.ZodObject: {
            const shape = def.shape();
            const keys = Object.keys(shape);
            return keys
                .map((key) => {
                return (0, exports.extractEnumJsonPaths)(shape[key], zodRuntime, [
                    ...currentPath,
                    key,
                ]);
            })
                .flat(1);
        }
        case zodRuntime.ZodFirstPartyTypeKind.ZodArray: {
            return (0, exports.extractEnumJsonPaths)(def.type, zodRuntime, [
                ...currentPath,
                '[]',
            ]);
        }
        case zodRuntime.ZodFirstPartyTypeKind.ZodUnion: {
            return def.options
                .map((option) => {
                return (0, exports.extractEnumJsonPaths)(option, zodRuntime, currentPath);
            })
                .flat(1);
        }
        case zodRuntime.ZodFirstPartyTypeKind.ZodDiscriminatedUnion: {
            return def.options
                .map((op) => {
                return (0, exports.extractEnumJsonPaths)(op, zodRuntime, currentPath);
            })
                .flat(1);
        }
        case zodRuntime.ZodFirstPartyTypeKind.ZodLiteral: {
            return [currentPath];
        }
        case zodRuntime.ZodFirstPartyTypeKind.ZodEffects: {
            return (0, exports.extractEnumJsonPaths)(def.schema, zodRuntime, currentPath);
        }
        case zodRuntime.ZodFirstPartyTypeKind.ZodIntersection: {
            const { left, right } = def;
            const leftValue = (0, exports.extractEnumJsonPaths)(left, zodRuntime, currentPath);
            const rightValue = (0, exports.extractEnumJsonPaths)(right, zodRuntime, currentPath);
            return [...leftValue, ...rightValue];
        }
        case zodRuntime.ZodFirstPartyTypeKind.ZodTuple: {
            return def.items
                .map((item, i) => (0, exports.extractEnumJsonPaths)(item, zodRuntime, [...currentPath, i]))
                .flat(1);
        }
        case zodRuntime.ZodFirstPartyTypeKind.ZodRecord: {
            const values = (0, exports.extractEnumJsonPaths)(def.valueType, zodRuntime, [...currentPath, '{}']);
            return values;
        }
        case zodRuntime.ZodFirstPartyTypeKind.ZodFunction: {
            throw new Error('Cannot create a value for type function');
        }
        case zodRuntime.ZodFirstPartyTypeKind.ZodEnum: {
            return [currentPath];
        }
        case zodRuntime.ZodFirstPartyTypeKind.ZodNativeEnum: {
            return [];
        }
        case zodRuntime.ZodFirstPartyTypeKind.ZodOptional: {
            const defType = def;
            const value = (0, exports.extractEnumJsonPaths)(defType.innerType, zodRuntime, currentPath);
            return value;
        }
        case zodRuntime.ZodFirstPartyTypeKind.ZodNullable: {
            const defType = def;
            const value = (0, exports.extractEnumJsonPaths)(defType.innerType, zodRuntime, currentPath);
            return value;
        }
        case zodRuntime.ZodFirstPartyTypeKind.ZodDefault: {
            const defType = def;
            return (0, exports.extractEnumJsonPaths)(defType.innerType, zodRuntime, currentPath);
        }
        case zodRuntime.ZodFirstPartyTypeKind.ZodCatch: {
            const defType = def;
            return (0, exports.extractEnumJsonPaths)(defType.innerType, zodRuntime, currentPath);
        }
        case zodRuntime.ZodFirstPartyTypeKind.ZodPromise: {
            return [];
        }
        case zodRuntime.ZodFirstPartyTypeKind.ZodBranded: {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            const defType = def;
            const value = (0, exports.extractEnumJsonPaths)(defType.type, zodRuntime, currentPath);
            return value;
        }
        case zodRuntime.ZodFirstPartyTypeKind.ZodPipeline: {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            const defType = def;
            const value = (0, exports.extractEnumJsonPaths)(defType.out, zodRuntime, currentPath);
            return value;
        }
        case zodRuntime.ZodFirstPartyTypeKind.ZodString:
        case zodRuntime.ZodFirstPartyTypeKind.ZodNumber:
        case zodRuntime.ZodFirstPartyTypeKind.ZodBigInt:
        case zodRuntime.ZodFirstPartyTypeKind.ZodBoolean:
        case zodRuntime.ZodFirstPartyTypeKind.ZodNaN:
        case zodRuntime.ZodFirstPartyTypeKind.ZodDate:
        case zodRuntime.ZodFirstPartyTypeKind.ZodSymbol:
        case zodRuntime.ZodFirstPartyTypeKind.ZodUndefined:
        case zodRuntime.ZodFirstPartyTypeKind.ZodNull:
        case zodRuntime.ZodFirstPartyTypeKind.ZodAny:
        case zodRuntime.ZodFirstPartyTypeKind.ZodUnknown:
        case zodRuntime.ZodFirstPartyTypeKind.ZodNever:
        case zodRuntime.ZodFirstPartyTypeKind.ZodVoid:
        case zodRuntime.ZodFirstPartyTypeKind.ZodMap: // Maps are not serializable
        case zodRuntime.ZodFirstPartyTypeKind.ZodLazy:
        case zodRuntime.ZodFirstPartyTypeKind.ZodSet: {
            // Sets are not serializable
            return [];
        }
        default:
            throw new Error('Not implemented: ' + typeName);
    }
};
exports.extractEnumJsonPaths = extractEnumJsonPaths;
